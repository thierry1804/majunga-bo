name: D√©ploiement FTP en Production

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  PHP_VERSION: '8.2'

jobs:
  deploy:
    name: D√©ploiement via FTP
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4

      - name: Configuration PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: ctype, iconv, pdo, pdo_pgsql
          coverage: none

      - name: Cr√©ation du fichier .env minimal pour le build
        run: |
          cat > .env << 'EOF'
          APP_ENV=prod
          APP_DEBUG=false
          APP_SECRET=build_secret_key_for_ci_cd_only_not_for_production
          DATABASE_URL="postgresql://user:password@localhost:5432/dbname?serverVersion=16&charset=utf8"
          DEFAULT_URI="http://localhost"
          MAILER_FROM_EMAIL="noreply@example.com"
          MAILER_FROM_NAME=""
          EOF

      - name: R√©cup√©ration du cache Composer
        uses: actions/cache@v4
        with:
          path: ~/.composer/cache
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: Installation des d√©pendances
        run: |
          composer install --no-dev --optimize-autoloader --no-interaction --prefer-dist

      - name: Optimisation du cache Symfony
        run: |
          php bin/console cache:clear --env=prod --no-debug || true
          php bin/console cache:warmup --env=prod --no-debug || true

      - name: Pr√©paration de l'archive ZIP
        run: |
          # Cr√©er un r√©pertoire de d√©ploiement
          mkdir -p deploy
          
          # Cr√©er l'archive ZIP de tout le projet (sauf fichiers sensibles)
          echo "Cr√©ation de l'archive ZIP compl√®te..."
          zip -r deploy/deployment.zip . \
            -x "*.git*" \
            -x "*/.env*" \
            -x "*/.env.local*" \
            -x "*/.env.*.local" \
            -x "*/var/cache/*" \
            -x "*/var/log/*" \
            -x "*/var/sessions/*" \
            -x "*/node_modules/*" \
            -x "*/.DS_Store" \
            -x "*/Thumbs.db" \
            -x "*/compose.yaml" \
            -x "*/compose.override.yaml" \
            -x "*/*.md" \
            -x "*/tests/*" \
            -x "*/.phpunit.result.cache" \
            -x "*/config/jwt/*.pem" \
            -x "*/config/secrets/prod/prod.decrypt.private.php"
          
          echo "Archive cr√©√©e : $(du -h deploy/deployment.zip | cut -f1)"
          
          # Cr√©er un script PHP complet qui automatise tout
          cat > deploy/deploy.php << 'PHPEOF'
          <?php
          /**
           * Script de d√©ploiement automatique complet
           * 
           * Ce script :
           * 1. Extrait l'archive deployment.zip
           * 2. Cr√©e les dossiers n√©cessaires
           * 3. Ex√©cute les migrations de base de donn√©es
           * 4. Vide et optimise le cache
           * 5. Nettoie les fichiers temporaires
           * 
           * Utilisation :
           * - Via le navigateur : https://api.madabooking.mg/deploy.php?token=VOTRE_TOKEN_SECRET
           * - Via SSH : php deploy.php
           * 
           * IMPORTANT : Configurez un token secret dans .env.local : DEPLOY_TOKEN=votre_token_secret
           * IMPORTANT : Supprimez ce fichier apr√®s utilisation pour des raisons de s√©curit√© !
           */
          
          header('Content-Type: text/html; charset=utf-8');
          
          $rootPath = __DIR__;
          $archivePath = $rootPath . '/deployment.zip';
          
          // V√©rification du token de s√©curit√© (si appel√© via HTTP)
          if (php_sapi_name() !== 'cli') {
              // Charger .env.local pour v√©rifier le token
              $envPath = $rootPath . '/.env.local';
              $deployToken = null;
              if (file_exists($envPath)) {
                  $envContent = file_get_contents($envPath);
                  if (preg_match('/^DEPLOY_TOKEN=(.+)$/m', $envContent, $matches)) {
                      $deployToken = trim($matches[1], '"\'');
                  }
              }
              
              $providedToken = $_GET['token'] ?? null;
              if ($deployToken && $providedToken !== $deployToken) {
                  http_response_code(403);
                  die("<h1>Acc√®s refus√©</h1><p>Token invalide. Configurez DEPLOY_TOKEN dans .env.local et utilisez-le dans l'URL : ?token=VOTRE_TOKEN</p>");
              }
          }
          
          echo "<h1>üöÄ D√©ploiement automatique en cours...</h1>";
          echo "<pre>";
          flush();
          
          $errors = [];
          $success = [];
          
          // 1. Extraction de l'archive
          if (!file_exists($archivePath)) {
              $errors[] = "L'archive deployment.zip n'existe pas";
              echo "‚ùå Erreur : L'archive deployment.zip n'existe pas\n";
          } else {
              if (!class_exists('ZipArchive')) {
                  $errors[] = "Extension ZipArchive non disponible";
                  echo "‚ùå Erreur : L'extension ZipArchive n'est pas disponible\n";
              } else {
                  echo "üì¶ √âtape 1/5 : Extraction de l'archive...\n";
                  flush();
                  
                  try {
                      $zip = new ZipArchive;
                      $result = $zip->open($archivePath);
                      
                      if ($result === TRUE) {
                          $zip->extractTo($rootPath);
                          $zip->close();
                          echo "‚úÖ Archive extraite avec succ√®s\n";
                          $success[] = "Archive extraite";
                      } else {
                          throw new Exception("Impossible d'ouvrir l'archive. Code : $result");
                      }
                  } catch (Exception $e) {
                      $errors[] = "Erreur lors de l'extraction : " . $e->getMessage();
                      echo "‚ùå Erreur : " . $e->getMessage() . "\n";
                  }
              }
          }
          
          // 2. Cr√©ation des dossiers n√©cessaires
          echo "\nüìÅ √âtape 2/5 : Cr√©ation des dossiers...\n";
          flush();
          $requiredDirs = ['var/cache', 'var/log', 'var/sessions'];
          foreach ($requiredDirs as $dir) {
              $fullPath = $rootPath . '/' . $dir;
              if (!is_dir($fullPath)) {
                  if (mkdir($fullPath, 0777, true)) {
                      echo "‚úÖ Dossier cr√©√© : $dir\n";
                      $success[] = "Dossier $dir cr√©√©";
                  } else {
                      $errors[] = "Impossible de cr√©er $dir";
                      echo "‚ùå Erreur : Impossible de cr√©er $dir\n";
                  }
              }
              if (is_dir($fullPath)) {
                  chmod($fullPath, 0777);
              }
          }
          
          // 3. V√©rification de l'autoloader
          $autoloadPath = $rootPath . '/vendor/autoload.php';
          if (!file_exists($autoloadPath)) {
              $errors[] = "vendor/autoload.php non trouv√©";
              echo "\n‚ùå Erreur : vendor/autoload.php non trouv√©. L'extraction a peut-√™tre √©chou√©.\n";
          } else {
              require_once $autoloadPath;
              
              // 4. Ex√©cution des migrations
              echo "\nüóÑÔ∏è √âtape 3/5 : Ex√©cution des migrations de base de donn√©es...\n";
              flush();
              
              try {
                  require_once $rootPath . '/src/Kernel.php';
                  $kernel = new \App\Kernel('prod', false);
                  $kernel->boot();
                  $application = new \Symfony\Bundle\FrameworkBundle\Console\Application($kernel);
                  $application->setAutoExit(false);
                  
                  // Ex√©cuter les migrations
                  $input = new \Symfony\Component\Console\Input\ArrayInput([
                      'command' => 'doctrine:migrations:migrate',
                      '--no-interaction' => true,
                      '--env' => 'prod',
                  ]);
                  $output = new \Symfony\Component\Console\Output\BufferedOutput();
                  
                  $exitCode = $application->run($input, $output);
                  $migrationOutput = $output->fetch();
                  
                  if ($exitCode === 0) {
                      echo "‚úÖ Migrations ex√©cut√©es avec succ√®s\n";
                      if ($migrationOutput) {
                          echo $migrationOutput . "\n";
                      }
                      $success[] = "Migrations ex√©cut√©es";
                  } else {
                      echo "‚ö†Ô∏è Migrations : " . $migrationOutput . "\n";
                      $errors[] = "Erreur lors des migrations";
                  }
              } catch (Exception $e) {
                  echo "‚ö†Ô∏è Impossible d'ex√©cuter les migrations : " . $e->getMessage() . "\n";
                  echo "   (Vous pouvez les ex√©cuter manuellement : php bin/console doctrine:migrations:migrate --no-interaction)\n";
              }
              
              // 5. Nettoyage du cache
              echo "\nüßπ √âtape 4/5 : Nettoyage et optimisation du cache...\n";
              flush();
              
              try {
                  $application = new \Symfony\Bundle\FrameworkBundle\Console\Application($kernel);
                  $application->setAutoExit(false);
                  
                  // Vider le cache
                  $input = new \Symfony\Component\Console\Input\ArrayInput([
                      'command' => 'cache:clear',
                      '--env' => 'prod',
                      '--no-debug' => true,
                  ]);
                  $output = new \Symfony\Component\Console\Output\BufferedOutput();
                  $application->run($input, $output);
                  
                  // Optimiser le cache
                  $input = new \Symfony\Component\Console\Input\ArrayInput([
                      'command' => 'cache:warmup',
                      '--env' => 'prod',
                      '--no-debug' => true,
                  ]);
                  $output = new \Symfony\Component\Console\Output\BufferedOutput();
                  $application->run($input, $output);
                  
                  echo "‚úÖ Cache optimis√©\n";
                  $success[] = "Cache optimis√©";
              } catch (Exception $e) {
                  echo "‚ö†Ô∏è Erreur lors de l'optimisation du cache : " . $e->getMessage() . "\n";
              }
          }
          
          // 6. Nettoyage des fichiers temporaires
          echo "\nüßπ √âtape 5/5 : Nettoyage des fichiers temporaires...\n";
          flush();
          
          $filesToDelete = [$archivePath, __FILE__];
          foreach ($filesToDelete as $file) {
              if (file_exists($file)) {
                  if (unlink($file)) {
                      echo "‚úÖ Fichier supprim√© : " . basename($file) . "\n";
                      $success[] = "Fichier " . basename($file) . " supprim√©";
                  } else {
                      echo "‚ö†Ô∏è Impossible de supprimer : " . basename($file) . "\n";
                  }
              }
          }
          
          // R√©sum√©
          echo "\n" . str_repeat("=", 50) . "\n";
          echo "<strong style='color: green;'>‚úÖ D√©ploiement termin√© !</strong>\n\n";
          echo "R√©sum√© :\n";
          echo "- Succ√®s : " . count($success) . "\n";
          echo "- Erreurs : " . count($errors) . "\n";
          
          if (!empty($errors)) {
              echo "\n‚ö†Ô∏è Erreurs rencontr√©es :\n";
              foreach ($errors as $error) {
                  echo "  - $error\n";
              }
          }
          
          echo "\n" . str_repeat("=", 50) . "\n";
          echo "</pre>";
          PHPEOF
          
          # Copier le script dans public/ pour qu'il soit accessible via le navigateur
          mkdir -p deploy/public
          cp deploy/deploy.php deploy/public/
          
      - name: D√©ploiement de l'archive ZIP via FTP
        uses: SamKirkland/FTP-Deploy-Action@v4.3.4
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          local-dir: ./deploy/
          server-dir: ${{ secrets.FTP_REMOTE_DIR }}
          log-level: verbose
          dangerous-clean-slate: false
          exclude: |
            **/.git*
            **/.git*/**
            **/deploy.php

      - name: Nettoyage
        if: always()
        run: |
          rm -rf deploy

